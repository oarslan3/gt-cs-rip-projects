#LyX 1.6.4 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 3cm
\topmargin 3cm
\rightmargin 3cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
CS8803 RIP Project 2: Motion Planning with RST
\end_layout

\begin_layout Author
Oktay Arslan, Alex Cunningham, Philip Rogers
\end_layout

\begin_layout Part
Rapidly Exploring Random Trees
\end_layout

\begin_layout Section
Planner Implementations
\end_layout

\begin_layout Subsection
Goal-Biased RRT (
\begin_inset Quotes eld
\end_inset

Greedy
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
In our goal-based RRT, we grow the tree in two ways: 
\end_layout

\begin_layout Enumerate
Random tree growth, as the classic RRT performs.
 New branches are created in random directions.
\end_layout

\begin_layout Enumerate
Biased tree growth, where new branches are made towards the direction of
 the goal.
\end_layout

\begin_layout Standard
The tradeoff between these two steps is governed by a greediness parameter,
 where higher values reduce the 
\begin_inset Quotes eld
\end_inset

breadth
\begin_inset Quotes erd
\end_inset

 of the tree in exchange for a tree grown directly towards the goal.
 Tuning this greediness parameter is important, as a high value may become
 trapped at an obstacle, but lower values are wasteful in that they may
 not grow towards the goal at every step.
\end_layout

\begin_layout Subsection
Bi-Directional RRT
\end_layout

\begin_layout Standard
Our bi-directional RRT is heavily based on the bi-directional algorithm
 presented in 
\begin_inset Quotes eld
\end_inset

Randomized Kinodynamic Planning
\begin_inset Quotes erd
\end_inset

 by LaValle and Kuffner.
 The extension to the classical RRT is to grow two trees towards each other.
 We do this by growing one tree (randomly, greedily, or using RRT Connect)
 and then grow the second tree towards the newest branch of the first tree
 (the 
\begin_inset Quotes eld
\end_inset

frontier
\begin_inset Quotes erd
\end_inset

.) We then do the same procedure, but starting with the second RRT, instead
 of the first.
 Because we have the option to use RRT Connect, our algorithm slightly differs
 from the bi-directional RRT presented by LaValle and Kuffner.
 As expected, we found the RRT Connect variant to improve the goal-biased
 RRT in scenarios where there are no or few obstacles.
\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard
We tested the implemented RRTs in two separate scenarios, the 
\begin_inset Quotes eld
\end_inset

ChairLamp
\begin_inset Quotes erd
\end_inset

 scenario provided with the default RST software, and the 
\begin_inset Quotes eld
\end_inset

FeedBear
\begin_inset Quotes erd
\end_inset

 scenario, which makes use of the robots constructed for Part II of this
 paper.
 For each of these scenarios, we used all combinations of Goal-Biased RRT,
 RRT Connect and Bidirectional RRT, and performed three tests to allow for
 variations due to the randomness of the algorithm.
 
\begin_inset Quotes eld
\end_inset

DNS
\begin_inset Quotes erd
\end_inset

 in the results table denotes scenarios where the software did not find
 a solution before the RRT grew outside of memory bounds.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Results for 
\begin_inset Quotes eld
\end_inset

ChairLamp
\begin_inset Quotes erd
\end_inset

 Scenario.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Greedy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Connect
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bi-Dir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Path Length
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Iterations
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tree Size
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
67/67/67
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0/0/0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
67/67/67
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
83/90/87
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
52/57/54
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
54/58/53
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
66/66/66
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0/0/0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
67/67/67
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
93/91/90
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
235/240/240
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
237/242/242
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename chairlamp.png
	width 10cm
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:RRT-Results-chairlamp"

\end_inset

RRT Results in the 
\begin_inset Quotes eld
\end_inset

ChairLamp
\begin_inset Quotes erd
\end_inset

 (DESKTOP-ARM-FINAL.rscene) scenario.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:feedbear_basic"

\end_inset

Results for 
\begin_inset Quotes eld
\end_inset

FeedBear
\begin_inset Quotes erd
\end_inset

 scenario
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Greedy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Connect
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bi-Dir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Path Length
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Iterations
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tree Size
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
137/139/139
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
877/1586/809
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
240/327/181
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
147/245/142
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1372/1851/1041
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
230/373/165
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120/DNS/120
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
860/DNS/1610
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
281/DNS/535
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DNS/DNS/DNS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DNS/DNS/DNS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DNS/DNS/DNS
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename feedbear.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:FeedBear-Scenario-(maze3.rscene)"

\end_inset

FeedBear Scenario (maze3.rscene).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Performance
\end_layout

\begin_layout Standard
In general, our results show that the bi-directional RRT using RRT Connect
 is superior to all other variants.
 Without RRT Connect, the bi-directional approach is still faster, on average.
\end_layout

\begin_layout Standard
In terms of finding a solution at all, the bi-directional approach seems
 to be the most important.
 In particular, the bi-directional RRT is able to find plans in scenarios
 where the goal is blocked by a concave obstacle; a situation where the
 goal-biased RRT may not find a solution at all.
 In the FeedBear experiment, the non-bidirection RRT can occasionally find
 a solution quickly, or it will completely fail to find a solution, because
 initial branching decisions trapped the tree behind an obstacle.
 We think this is because the bi-directional RRT is better at growing 
\begin_inset Quotes eld
\end_inset

around
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

out
\begin_inset Quotes erd
\end_inset

 of obstacles than a vanilla RRT.
 Consider the example below, that shows a goal-biased RRT and a bi-directional
 RRT:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename rrt_vs_birrt.eps

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Simple scenario where a bi-directional RRT can improve performance by more
 effectively handling concave obstacles.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\end_layout

\end_inset


\end_layout

\begin_layout Standard
For a real example of the above scenario, we built the following scenario
 which the non-bi-directional RRTs were not able to solve:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename schunkstuck.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Arm planning scenario where non-bidirectional RRTs fail due to concave obstacles.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In terms of the speed of the planner (number of iterations), the bi-directional
 RRT is similar to the goal-biased RRT, except when the goal-biased RRT
 cannot find a solution.
 This is somewhat to be expected, as the bi-directional approach is similar
 to the goal-biased, except that it grows from two trees.
\end_layout

\begin_layout Subsection
Solution Quality
\end_layout

\begin_layout Standard
One measure of the quality of the plan generated (beyond being able to generate
 a plan at all) is the path length.
 The rationale behind this is that longer paths are wasteful and less 
\begin_inset Quotes eld
\end_inset

direct.
\begin_inset Quotes erd
\end_inset

 In our tests, the use of RRT Connect was one of the largest factors, where
 RRT Connect generally reduced the path length.
 It is interesting to note that the bi-directional RRT generally produced
 poorer paths than the goal-biased RRT.
 We think that this may be because the one of the bi-directional trees would
 sometimes grow away from the line-of-sight solution, but the RRT would
 find a complete path using the second tree.
\end_layout

\begin_layout Standard
A second measure of the quality of the plan generated is the smoothness
 of the path.
 For this section of the paper, this is a more quantitative criterion, but
 RRT Connect strongly determined how 
\begin_inset Quotes eld
\end_inset

straight
\begin_inset Quotes erd
\end_inset

 the plan is.
 The bi-directional RRT, when not using RRT Connect, produced paths that
 wandered more away from optimial routes.
 This effect is largely due to RRT Connect's capacity to drive the robot
 in long straight lines whenever possible.
 We expand on the smoothness of paths in Part II, below.
\end_layout

\begin_layout Part
Broader Goals in Motion Planning
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
Our final goal is to develop a maze-solving robot using RRTs, and compare
 the results of our various RRT variants (goal-based RRT, bi-directional
 RRT, RRT Connect).
 To achieve this goal, we implemented three of the suggested subprojects
 of the assignment:
\end_layout

\begin_layout Enumerate
Robot Construction: We created two new robots for solving our mazes.
\end_layout

\begin_layout Enumerate
Mobile Manipulation: Our two robots are going places and doing stuff! Our
 mazes require more than just getting the robot from one place to another:
 we use both the robot's movement and the robot's manipulators to reach
 a goal.
\end_layout

\begin_layout Enumerate
Path Optimization: The paths generated in our vanilla RRT are not smooth.
 We implemented two methods to improve our paths: path shortening, and spline-ba
sed smoothing.
\end_layout

\begin_layout Subsection
Robot Construction
\end_layout

\begin_layout Standard
We built two maze solving robots: AMazeBot and AMazeHelicopter.
 In addition, we built a variety of mazes for them to solve, which include
 dead ends and places that only the manipulators can reach.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename bothrobots.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Robots constructed for this project: AMazeHelicopter (left) and AMazeBot.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
MIT recently showed the indoor autonomous navigation of quadrotor helicopters
 and our project of indoor maze solving is based on this idea.
 AMazeHelicopter features a Schunk manipulator bolted to an ultralight quadrotor
 helicopter.
 The flying component is based off of Ascending Technology's ultralight
 (5.3kg) X-3D-BL quadrotor helicopter.
 The manipulator is an 18.7kg Schunk arm and is attached to the bottom of
 the helicopter.
 The Schunk hand was not attached, as the additional weight would render
 the robot too heavy to fly reliably.
 As suggested in the project description, we used three prismatic joints
 for the translation of the helicopter in three dimensions, as well as a
 yaw rotation, which is roughly consistent with the helicopter's real motion,
 assuming flight stabilization.
\end_layout

\begin_layout Standard
AMazeBot is a Schunk arm bolted to a segway base, similar to Golem.
 It has two prismatic joints, which do not correctly model the physics of
 the robot, but which can be used to generate paths.
 The paths generated using AMazeBot show situations where the robot moves
 horizontally (against the direction of the wheels) which is something we
 would fix if we had additional time.
\end_layout

\begin_layout Subsection
Mobile Manipulation
\end_layout

\begin_layout Standard
Our task is to solve mazes using RRTs which involve both the mobile robot
 and the use of a manipulator.
 The goal in most of our mazes is to get the robot through the maze and
 get the manipulator into a given configuration, with one of the main scenarios
 being the FeedBear scenario (pictured in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:FeedBear-Scenario-(maze3.rscene)"

\end_inset

).
 
\end_layout

\begin_layout Subsection
Path Optimization
\end_layout

\begin_layout Standard
The paths generated from the RRT are generally not smooth.
 We use two methods for path optimization:
\end_layout

\begin_layout Enumerate
Path shortening: We remove intermediate configurations in the path that
 do not cause collisions.
\end_layout

\begin_layout Enumerate
Path smoothing: We use splines to smooth the overall path.
\end_layout

\begin_layout Standard
We found that the two methods, combined, generated both better paths (shorter)
 and more realistic paths (natural looking.)
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
Our project primarily deals with the mobile manipulation and path optimization
 components from above.
 
\end_layout

\begin_layout Standard
The mobile manipulation results are relatively good for simple mazes, but
 require a large amount of parameter knob turning to work with complex mazes.
 A difficulty in using RRTs to solve mazes is that obstacles in configuration
 space are very different from obstacles in joint space.
 We noticed that the RRTs would get 
\begin_inset Quotes eld
\end_inset

stuck
\begin_inset Quotes erd
\end_inset

 on long, thin walls no matter which variant of the RRT we used.
 This is because a goal on one side of the wall is very similar to a goal
 on the other, and the RRTs take a very long time (if ever) to determine
 that one of the translational prismatic joints must be moved way up, then
 way down to get around the obstacle.
 To get around this, we chose to use large, convex obstacles in our mazes,
 where possible.
\end_layout

\begin_layout Standard
The path optimization has two main portions which are run in sequence: a
 path shortening algorithm, which finds shortcuts in the path where possible,
 and a smoothing algorithm, which makes use of the existing CubicViaSpline
 implementation provided in RST software.
 These were implemented in a separate module that performed the optimization
 after the planner created the paths.
\end_layout

\begin_layout Subsection
Path Shortening
\end_layout

\begin_layout Standard
The path shortening algorithm is a robust algorithm which searches the path
 for any two configurations that can be connected with a straight line.
 The inner portion of the path shortening algorithm takes two points in
 a path, and attempts to find a straight-line path through configuration
 space that connects the points.
 We evaluate this 
\begin_inset Quotes eld
\end_inset

shortcut
\begin_inset Quotes erd
\end_inset

 between the points by using a process like RRT Connect to incrementally
 extend from one point to the next.
 If a collision-free shortcut exists, then the segment between the pair
 of points in the path is replaced with the shortcut.
 It should be noted that if a collision-free shortcut exists, then it must
 be as short or shorter than the existing path between the two points.
 
\end_layout

\begin_layout Standard
In order to ensure that the path is as short as is possible by using shortcut
 methods, we test every pair of points in the path, starting with an initial
 pair of the path start and end points.
 When shortcuts are inserted into the path, we start the search on the entire
 path again to ensure that no more possible shortcuts have been created.
 The actual performance of this algorithm is quite slow (several minutes
 for optimization in our FeedBear experiments) because it will continue
 until there exist no shortcuts between any two points anywhere in the path.
 The nature of the path shortening, in scenarios where there are no obstacles,
 force the path to a straight line.
\end_layout

\begin_layout Standard
The primary challenge in this system was to ensure that the algorithm would
 eventually halt, which as if the stepsize used in the shortcut evaluation
 is too small, the collision detections will make take a very long time.
 The primary means of solving these problems was to perform a small series
 of tests, such as rotating an arm around a single axis, or flying a helicopter
 in a straight line.
 By starting with small examples, which are simple enough that the paths
 can be printed and interpreted manually, we could effectively test the
 system an ensure its functionality.
 
\end_layout

\begin_layout Standard
This algorithm, while very slow, does provide an optimal path shortening,
 which resulted in robots hugging walls as they moved around obstacles.
 In some cases, the improvement is dramatic, as the initial path would wander
 away from the goal at some points before closing in on the goal.
 The optimized version is significnatly faster and more direct.
 The main places for improvement in this algorithm are in the searching
 algorithm that finds the pairs of points for which to test shortcuts.
 Right now, the algorithm uses a naive linear search, which is approximately
 
\begin_inset Formula $O(n^{2})$
\end_inset

 for search for the furthest apart points in the path with an existing shortcut.
 Using a binary search, this could be reduced to 
\begin_inset Formula $O(n\log(n))$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
***NOTE TO ALEX: I think we should remove this last sentence.
 Would a binary search still provide an optimal path? I don't think it will.
 I think there is an O(n log(n)) algorithm (not a binary search though),
 based on voronoi diagrams, but I think it's best if we just axe the last
 sentence and leave it at that :)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Path Smoothing
\end_layout

\begin_layout Standard
Path smoothing executed after the initially planned path had been shortened
 as in the previous section.
 The path smoothing algorithm used the existing implementation of spline
 fitting in RST to interpolate the shortened path.
 A CubicViaSpline was used in this case to perform the interpolation, where
 we inserted the entire shortened path at regular time intervals into the
 spline and then resampled the spline at a sampling rate of twice the shorten
 path's length.
 After creating a subsampled version of the path, we removed any of the
 interpolated configurations with collisions.
 
\end_layout

\begin_layout Standard
The results of this path smoothing system were less dramatic due to the
 uniform distribution of the initial samples, which bind the path rather
 tightly to the existing shortened path.
 Smaller, single-acutator test scenarios showed that the smoothing did not
 only perform linear interpolation, but also added inertial effects to that
 were apparent near the ends of the trajectory, as the robot slowed to a
 stop just before the end.
 There are a number of ways to improve this system, such as constructing
 the shortened path such that it does not create intermediate states for
 shortcuts, and then using the distance between jumps as a means of distributing
 the configurations in time.
 A smaller number of configurations, with larger spaces between them, would
 allow for the splines to do more fitting.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
For each of the extensions you perform, summarize your experiences and findings.
 Discuss the challenges you faced and how you overcame them.
 Describe the performance of your algorithms and any particularly interesting
 results.
 Conclude with what you would have done to improve your extension if you
 could stop the hands of time.
 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
